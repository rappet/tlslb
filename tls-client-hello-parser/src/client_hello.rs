use core::fmt::Debug;

use heapless::Vec;
use nom7::{
    IResult, InputLength, Parser,
    bytes::streaming::take,
    combinator::{complete, cond, map_parser, opt, verify},
    error::{ErrorKind, ParseError, make_error},
    multi::length_data,
    number::{
        Endianness,
        complete::{u8, u16},
        streaming::{be_u8, be_u16, be_u24},
    },
};

use crate::TlsParseError;

/// Extracted information needed
/// to route and fingerprint TLS sessions
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClientHello<'a> {
    tls_version: u16,
    sni: Option<&'a str>,
    cipher_suites: Vec<u16, 128>,
    extensions: Vec<u16, 128>,
    signature_algorithms: Vec<u16, 30>,
    alpn: Vec<&'a [u8], 4>,
}

impl<'a> ClientHello<'a> {
    /// Highest TLS version supported by the client, without grease
    pub fn tls_version(&self) -> u16 {
        self.tls_version
    }

    /// Server Name Identification extracted from the packet
    ///
    /// In case the target is an IP address _or_ ECH is used, this is None
    ///
    /// **TODO** verify above statement
    pub fn sni(&self) -> Option<&str> {
        self.sni
    }

    /// Cipher Suites supported by the client, without grease
    pub fn cipher_suites(&self) -> &[u16] {
        &self.cipher_suites
    }

    /// Extension IDs in the Client Hello, without grease
    pub fn extensions(&self) -> &[u16] {
        &self.extensions
    }

    /// Signatures algorithm IDs, without grease
    pub fn signature_algorithms(&self) -> &[u16] {
        &self.signature_algorithms
    }

    /// ALPN values, without grease
    pub fn alpn(&self) -> &[&[u8]] {
        &self.alpn
    }
}

impl<'a> TryFrom<&'a [u8]> for ClientHello<'a> {
    type Error = TlsParseError;

    fn try_from(value: &'a [u8]) -> Result<Self, Self::Error> {
        match parse_tls_client_hello(value) {
            Ok(v) => Ok(v),
            Err(nom7::Err::Incomplete(_)) => Err(TlsParseError::Incomplete),
            Err(nom7::Err::Error(e) | nom7::Err::Failure(e)) => Err(e),
        }
    }
}

/// Extracts useful metadata out of a TLS client hello
///
/// # Errors
/// If the input is malformed or not complete
pub fn parse_tls_client_hello(buffer: &[u8]) -> Result<ClientHello, nom7::Err<TlsParseError>> {
    let (_rest, client_hello) = extract_metadata_from_packet(buffer)?;
    Ok(client_hello)
}

pub const MAX_RECORD_LEN: u16 = (1 << 14) + 256;

/// Parse one packet only, as plaintext
/// A single record can contain multiple messages, they must share the same record type
fn extract_metadata_from_packet(i: &[u8]) -> IResult<&[u8], ClientHello, TlsParseError> {
    let (i, record_type) =
        u8(i).map_err(|e| e.map(|_: nom7::error::Error<&[u8]>| TlsParseError::ParseOuterPacket))?;
    let (i, _tls_version) = u16(Endianness::Big)(i)
        .map_err(|e| e.map(|_: nom7::error::Error<&[u8]>| TlsParseError::ParseOuterPacket))?;
    let (i, record_header_length) = u16(Endianness::Big)(i)
        .map_err(|e| e.map(|_: nom7::error::Error<&[u8]>| TlsParseError::ParseOuterPacket))?;

    if record_header_length > MAX_RECORD_LEN {
        return Err(nom7::Err::Error(TlsParseError::ParseOuterPacket));
    }
    let (i, client_hello) = map_parser(take(record_header_length as usize), |i| {
        extract_metadata_from_tls_record_with_header(i, record_type)
    })(i)
    .map_err(|e| e.map(|_| TlsParseError::ParseOuterPacket))?;
    Ok((i, client_hello))
}

/// Given data and a TLS record header, parse content.
///
/// A record can contain multiple messages (with the same type).
///
/// Note that message length is checked (not required for parser safety, but for
/// strict protocol conformance).
#[rustfmt::skip]
#[allow(clippy::trivially_copy_pass_by_ref)] // TlsRecordHeader is only 6 bytes, but we prefer not breaking current API
fn extract_metadata_from_tls_record_with_header<'i>(i:&'i [u8], record_type: u8) -> IResult<&'i [u8], ClientHello<'i>> {
    match record_type {
        // handshake
        0x16        => complete(extract_metadata_from_tls_message_handshake)(i),
        _                               => Err(nom7::Err::Error(make_error(i, ErrorKind::Switch)))
    }
}

/// Parse a TLS handshake message
fn extract_metadata_from_tls_message_handshake(i: &[u8]) -> IResult<&[u8], ClientHello> {
    let (i, ht) = be_u8(i)?;
    let (i, hl) = be_u24(i)?;
    let (i, raw_msg) = take(hl)(i)?;
    let (_, client_hello) = match ht {
        // client hello
        0x01 => extract_metadata_from_tls_handshake_client_hello(raw_msg),
        _ => Err(nom7::Err::Error(make_error(i, ErrorKind::Switch))),
    }?;
    Ok((i, client_hello))
}

fn extract_metadata_from_tls_handshake_client_hello(i: &[u8]) -> IResult<&[u8], ClientHello> {
    let (i, version) = be_u16(i)?;
    let (i, _random) = take(32usize)(i)?;
    let (i, sidlen) = verify(be_u8, |&n| n <= 32)(i)?;
    let (i, _sid) = cond(sidlen > 0, take(sidlen as usize))(i)?;
    let (i, ciphers_len) = be_u16(i)?;
    let (i, cipher_suites) = parse_cipher_suites(i, ciphers_len as usize)?;
    let (i, comp_len) = be_u8(i)?;
    // must be zero after TLS 1.3
    let (i, _comp) = take(comp_len as usize)(i)?;
    let (i, ext) = opt(complete(length_data(be_u16)))(i)?;
    //let content = TlsClientHelloContents::new(version, random, sid, ciphers, comp, ext);

    let mut client_hello = ClientHello {
        tls_version: version,
        sni: None,
        cipher_suites,
        extensions: Vec::new(),
        signature_algorithms: Vec::new(),
        alpn: Vec::new(),
    };

    if let Some(mut ext) = ext {
        while let Ok(v) = complete(parse_tls_extension_header)(ext) {
            ext = v.0;
            let (extension_id, extension_data) = v.1;
            if !is_grease(extension_id) {
                client_hello.extensions.push(extension_id).map_err(|_| {
                    nom7::Err::Failure(ParseError::from_error_kind(i, ErrorKind::TooLarge))
                })?;
                extract_extension_metadata(extension_id, extension_data, &mut client_hello);
            }
        }
    }

    Ok((i, client_hello))
}

pub(crate) fn parse_tls_extension_header(i: &[u8]) -> IResult<&[u8], (u16, &[u8])> {
    let (i, ext_type) = be_u16(i)?;
    let (i, ext_data) = length_data(be_u16)(i)?;
    Ok((i, (ext_type, ext_data)))
}

pub(crate) fn parse_cipher_suites(i: &[u8], len: usize) -> IResult<&[u8], Vec<u16, 128>> {
    if len == 0 {
        return Ok((i, Vec::new()));
    }
    if len % 2 == 1 || len > i.len() {
        return Err(nom7::Err::Error(make_error(i, ErrorKind::LengthValue)));
    }
    let v = i[..len]
        .chunks(2)
        .map(|chunk| u16::from(chunk[0]) << 8 | u16::from(chunk[1]))
        .filter(|v| !is_grease(*v))
        .collect();
    Ok((&i[len..], v))
}

fn extract_extension_metadata<'a>(
    extension_id: u16,
    extension_data: &'a [u8],
    client_hello: &mut ClientHello<'a>,
) -> Option<()> {
    match extension_id {
        // SNI
        0 => {
            let (_i, sni) = parse_tls_extension_sni_content(extension_data).ok()?;

            if let Some(sni_content_str) = sni.and_then(|entry| core::str::from_utf8(entry).ok()) {
                client_hello.sni = Some(sni_content_str);
            }
        }
        // Signature Algorithms
        13 => {
            let (_i, mut signature_algorithms): (_, Vec<_, 30>) = map_parser(
                length_data(be_u16::<_, ()>),
                many0_heapless(complete(be_u16)),
            )(extension_data)
            .ok()?;
            signature_algorithms.retain(|&v| !is_grease(v));
            client_hello
                .signature_algorithms
                .extend_from_slice(&signature_algorithms)
                .ok()?;
        }
        // ALPN
        16 => {
            let (_i, alpn): (_, Vec<_, 4>) = map_parser(
                length_data(be_u16::<_, ()>),
                many0_heapless(complete(length_data(be_u8))),
            )(extension_data)
            .ok()?;
            client_hello.alpn.extend_from_slice(&alpn).ok()?;
        }
        // supported versions
        43 => {
            let (_i, v) =
                parse_tls_extension_supported_versions_content_and_extract_highest(extension_data)
                    .ok()?;
            if let Some(v) = v {
                client_hello.tls_version = v;
            }
        }
        // ESNI
        0xffce => {
            //warn!("got ESNI :(");
        }
        _ => {
            // we do not care
        }
    }

    Some(())
}

/// A TLS header should only contain one Sni Entry per type
///
/// As currently only one type is defined this is an option.
// struct {
//     ServerName server_name_list<1..2^16-1>
// } ServerNameList;
fn parse_tls_extension_sni_content(i: &[u8]) -> IResult<&[u8], Option<&[u8]>> {
    if i.is_empty() {
        // special case: SNI extension in server can be empty
        return Ok((i, None));
    }
    let (i, list_len) = be_u16(i)?;
    if list_len == 0 {
        return Ok((i, None));
    }

    // we just take the first one
    // TODO the first one with the specific type
    let (i, v) = map_parser(take(list_len), complete(parse_tls_extension_sni_hostname))(i)?;
    Ok((i, Some(v)))
}

// struct {
//     NameType name_type;
//     select (name_type) {
//         case host_name: HostName;
//     } name;
// } ServerName;
//
// enum {
//     host_name(0), (255)
// } NameType;
//
// opaque HostName<1..2^16-1>;
fn parse_tls_extension_sni_hostname(i: &[u8]) -> IResult<&[u8], &[u8]> {
    let (i, t) = u8(i)?;
    let (i, v) = length_data(be_u16)(i)?;

    if t != 0 {
        // TODO Skip?
        return Err(nom7::Err::Error(make_error(i, ErrorKind::Verify)));
    }

    Ok((i, v))
}

// TLS 1.3 draft 23
//       struct {
//           select (Handshake.msg_type) {
//               case client_hello:
//                    ProtocolVersion versions<2..254>;
//
//               case server_hello: /* and HelloRetryRequest */
//                    ProtocolVersion selected_version;
//           };
//       } SupportedVersions;
// XXX the content depends on the current message type
// XXX first case has length 1 + 2*n, while the second case has length 2
fn parse_tls_extension_supported_versions_content_and_extract_highest(
    i: &[u8],
) -> IResult<&[u8], Option<u16>> {
    let ext_len = i.len();
    if ext_len == 2 {
        be_u16(i).map(|(i, v)| (i, Some(v)))
    } else {
        let (i, _) = be_u8(i)?;
        if ext_len == 0 {
            return Err(nom7::Err::Error(make_error(i, ErrorKind::Verify)));
        }
        let (i, l) = map_parser(take(ext_len - 1), parse_tls_versions_and_extract_highest)(i)?;
        Ok((i, l))
    }
}

pub(crate) fn parse_tls_versions_and_extract_highest(i: &[u8]) -> IResult<&[u8], Option<u16>> {
    let len = i.len();
    if len == 0 {
        return Ok((i, None));
    }
    if len % 2 == 1 || len > i.len() {
        return Err(nom7::Err::Error(make_error(i, ErrorKind::LengthValue)));
    }
    let v = (i[..len])
        .chunks(2)
        .map(|chunk| u16::from(chunk[0]) << 8 | u16::from(chunk[1]))
        .filter(|&v| !is_grease(v))
        .fold(0, u16::max);
    Ok((&i[len..], Some(v)))
}

/// "Inspired" from nom
///
/// Repeats the embedded parser, gathering the results in a `Vec`.
///
/// This stops on [`nom7::Err::Error`] and returns the results that were accumulated. To instead chain an error up, see
/// [`cut`][crate::combinator::cut].
///
/// # Arguments
/// * `f` The parser to apply.
///
/// *Note*: if the parser passed in accepts empty inputs (like `alpha0` or `digit0`), `many0` will
/// return an error, to prevent going into an infinite loop
fn many0_heapless<const N: usize, I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O, N>, E>
where
    I: Clone + InputLength,
    F: Parser<I, O, E>,
    E: ParseError<I>,
    O: Default + Debug,
{
    move |mut i: I| {
        let mut acc = Vec::new();
        loop {
            let len = i.input_len();
            match f.parse(i.clone()) {
                Err(nom7::Err::Error(_)) => return Ok((i, acc)),
                Err(e) => return Err(e),
                Ok((i1, o)) => {
                    // infinite loop check: the parser must always consume
                    if i1.input_len() == len {
                        return Err(nom7::Err::Error(E::from_error_kind(i, ErrorKind::Many0)));
                    }

                    acc.push(o)
                        .map_err(|_| nom7::Err::Error(E::from_error_kind(i, ErrorKind::Many0)))?;
                    i = i1
                }
            }
        }
    }
}

#[inline]
pub(crate) fn is_grease(number: u16) -> bool {
    let high = u8::try_from((number >> 8) & 0xff).expect("impossible");
    let low = u8::try_from(number & 0xff).expect("impossible");
    high == low && low & 0x0F == 0x0A
}

#[cfg(test)]
mod tests {
    use heapless::Vec;
    use pretty_assertions::assert_eq;

    use crate::{
        ClientHello,
        ja4::{Ja4Fingerprint, u16_slice_to_hex},
    };

    #[test]
    fn test_parse_tls_header() {
        const HEADER: &[u8] = &[
            0x16, 0x3, 0x1, 0x6, 0x28, 0x1, 0x0, 0x6, 0x24, 0x3, 0x3, 0xc3, 0xf0, 0xe7, 0xdb, 0x39,
            0x40, 0x1a, 0x7d, 0x96, 0xee, 0xa6, 0x49, 0xe3, 0xb9, 0x31, 0xf3, 0x5e, 0xf4, 0x52,
            0xd7, 0x31, 0x17, 0xd9, 0x27, 0xb3, 0x4c, 0xb4, 0x2c, 0xef, 0x25, 0x47, 0xbe, 0x20,
            0x68, 0xb5, 0xcc, 0xc3, 0xf5, 0xad, 0xc1, 0xf7, 0x64, 0x6b, 0x2a, 0xa8, 0x74, 0xc8,
            0x27, 0x92, 0xce, 0x57, 0x3, 0x90, 0xd9, 0xf9, 0x44, 0x55, 0x88, 0x68, 0x76, 0x37,
            0xfb, 0x23, 0x91, 0x6f, 0x0, 0x3c, 0x13, 0x2, 0x13, 0x3, 0x13, 0x1, 0xc0, 0x2c, 0xc0,
            0x30, 0x0, 0x9f, 0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f, 0x0, 0x9e,
            0xc0, 0x24, 0xc0, 0x28, 0x0, 0x6b, 0xc0, 0x23, 0xc0, 0x27, 0x0, 0x67, 0xc0, 0xa, 0xc0,
            0x14, 0x0, 0x39, 0xc0, 0x9, 0xc0, 0x13, 0x0, 0x33, 0x0, 0x9d, 0x0, 0x9c, 0x0, 0x3d,
            0x0, 0x3c, 0x0, 0x35, 0x0, 0x2f, 0x1, 0x0, 0x5, 0x9f, 0xff, 0x1, 0x0, 0x1, 0x0, 0x0,
            0x0, 0x0, 0x23, 0x0, 0x21, 0x0, 0x0, 0x1e, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e,
            0x67, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x6d, 0x6f,
            0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x2e, 0x6f, 0x72, 0x67, 0x0, 0xb, 0x0, 0x4, 0x3, 0x0,
            0x1, 0x2, 0x0, 0xa, 0x0, 0x12, 0x0, 0x10, 0x11, 0xec, 0x0, 0x1d, 0x0, 0x17, 0x0, 0x1e,
            0x0, 0x18, 0x0, 0x19, 0x1, 0x0, 0x1, 0x1, 0x0, 0x10, 0x0, 0xe, 0x0, 0xc, 0x2, 0x68,
            0x32, 0x8, 0x68, 0x74, 0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31, 0x0, 0x16, 0x0, 0x0, 0x0,
            0x17, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0xd, 0x0, 0x36, 0x0, 0x34, 0x9, 0x5, 0x9,
            0x6, 0x9, 0x4, 0x4, 0x3, 0x5, 0x3, 0x6, 0x3, 0x8, 0x7, 0x8, 0x8, 0x8, 0x1a, 0x8, 0x1b,
            0x8, 0x1c, 0x8, 0x9, 0x8, 0xa, 0x8, 0xb, 0x8, 0x4, 0x8, 0x5, 0x8, 0x6, 0x4, 0x1, 0x5,
            0x1, 0x6, 0x1, 0x3, 0x3, 0x3, 0x1, 0x3, 0x2, 0x4, 0x2, 0x5, 0x2, 0x6, 0x2, 0x0, 0x2b,
            0x0, 0x5, 0x4, 0x3, 0x4, 0x3, 0x3, 0x0, 0x2d, 0x0, 0x2, 0x1, 0x1, 0x0, 0x33, 0x4, 0xea,
            0x4, 0xe8, 0x11, 0xec, 0x4, 0xc0, 0x93, 0x62, 0x71, 0x8b, 0xb1, 0x69, 0xc2, 0xd0, 0x4b,
            0xc7, 0x66, 0xbc, 0xe, 0x17, 0x20, 0x25, 0xda, 0x9, 0x8b, 0x36, 0x18, 0xaa, 0x8b, 0x87,
            0xfd, 0xc3, 0xb0, 0xa6, 0x2b, 0x88, 0xd1, 0x8c, 0xa7, 0x2a, 0x5c, 0x6, 0xa4, 0xe1,
            0x26, 0x3e, 0x9, 0x52, 0x15, 0xa3, 0x1c, 0xca, 0xf7, 0x5a, 0xba, 0xf6, 0x5e, 0xd5,
            0x85, 0x69, 0x75, 0x88, 0x45, 0x5d, 0x72, 0x70, 0xf2, 0xd2, 0x11, 0x63, 0xa3, 0xa7,
            0xb8, 0x67, 0xa4, 0x1f, 0x89, 0xc0, 0x30, 0xb2, 0x19, 0x47, 0x69, 0x1c, 0xd8, 0xc3,
            0x40, 0x7e, 0xd9, 0x7, 0x8e, 0x6b, 0x2a, 0x54, 0x98, 0xca, 0xab, 0xd8, 0x26, 0x1a,
            0xd5, 0x64, 0x65, 0xd5, 0x90, 0xb, 0x19, 0x55, 0xba, 0x22, 0x7c, 0x77, 0x5c, 0x4b,
            0x85, 0x81, 0x82, 0x1d, 0xaa, 0x20, 0x2a, 0xb, 0x6d, 0x6d, 0x13, 0x71, 0xc0, 0xa, 0x69,
            0x13, 0xb3, 0xaf, 0xc0, 0xdc, 0x79, 0x49, 0x65, 0x5a, 0xd7, 0x10, 0x80, 0xd5, 0x53,
            0x5b, 0xcc, 0xe8, 0xc, 0x5a, 0x14, 0x55, 0xa, 0xa5, 0x93, 0x3d, 0xa, 0x28, 0x1a, 0xe0,
            0xa, 0x74, 0x99, 0xc7, 0x9, 0x9b, 0x47, 0x34, 0x53, 0xa7, 0xf7, 0x1a, 0x83, 0xf3, 0x17,
            0x6c, 0x5d, 0xfb, 0x1, 0xde, 0x51, 0x6f, 0xdf, 0xdb, 0x49, 0x1, 0xd3, 0xa2, 0xa3, 0xb2,
            0xa6, 0xeb, 0x7b, 0x78, 0x5e, 0xf4, 0xc9, 0xbb, 0xec, 0x6b, 0x8f, 0xd7, 0xb6, 0x93,
            0x7c, 0x9d, 0xe2, 0x24, 0x35, 0x86, 0xec, 0x5b, 0xa7, 0x67, 0x48, 0x6d, 0xf3, 0x3f,
            0x2b, 0xd4, 0x25, 0x4d, 0xa6, 0xad, 0x10, 0x2c, 0x31, 0x99, 0x1c, 0x72, 0x3e, 0x26,
            0x5a, 0x61, 0x56, 0xc3, 0x42, 0xd6, 0xb8, 0x43, 0x4a, 0x35, 0xf4, 0x92, 0x56, 0xa,
            0xc1, 0x1f, 0xdb, 0x3, 0x24, 0xd8, 0x49, 0xc7, 0x6b, 0x63, 0x31, 0x90, 0x4b, 0x74,
            0xd4, 0x76, 0x8c, 0x29, 0x51, 0x38, 0x32, 0x46, 0x6b, 0x81, 0xc0, 0x82, 0xaa, 0x84,
            0x34, 0x8c, 0x1a, 0x1d, 0x89, 0x4, 0x98, 0x69, 0x23, 0x5e, 0x49, 0x4b, 0x45, 0x51,
            0xd0, 0x45, 0x5, 0xa1, 0xc9, 0x42, 0xc2, 0xc3, 0x70, 0xeb, 0x9b, 0x32, 0xc8, 0xc8,
            0xe8, 0x39, 0xb8, 0xac, 0x9, 0xb0, 0x3, 0x3, 0x66, 0xc9, 0x67, 0x8d, 0xab, 0xc9, 0xb6,
            0x8f, 0xaa, 0x2a, 0x4a, 0x67, 0xcd, 0xfc, 0xe5, 0xc7, 0x97, 0xa1, 0xb8, 0xe5, 0xc8,
            0x2d, 0x1e, 0x65, 0x14, 0x92, 0xbc, 0xc, 0xb0, 0xe4, 0x61, 0xe4, 0x57, 0x7d, 0x61,
            0x56, 0x53, 0x5b, 0xc1, 0x6c, 0xfa, 0x87, 0x41, 0x20, 0xfc, 0x1c, 0x7, 0xdc, 0x92,
            0x26, 0x73, 0x3a, 0xd8, 0xa4, 0x2f, 0x34, 0xf0, 0x81, 0x1e, 0xd1, 0x88, 0x15, 0x67,
            0x4d, 0x1e, 0x1b, 0xc0, 0x3e, 0x96, 0xcb, 0x4d, 0x91, 0xb8, 0x64, 0x3a, 0x78, 0xc0,
            0xa4, 0x7a, 0xc9, 0x56, 0x17, 0xba, 0x8a, 0x34, 0xb7, 0xf6, 0x87, 0x96, 0xd9, 0x60,
            0x66, 0xcc, 0xf, 0xd, 0xc3, 0x2b, 0xc6, 0xb2, 0x80, 0xb3, 0x12, 0x6c, 0x72, 0x84, 0x3e,
            0xcb, 0x49, 0x38, 0x48, 0xfc, 0x12, 0x28, 0x82, 0x8d, 0x2d, 0x92, 0x42, 0xc2, 0x25,
            0x6d, 0x87, 0x37, 0x7d, 0x6a, 0x94, 0x77, 0xe9, 0xd7, 0x61, 0x20, 0x68, 0xbd, 0xc5,
            0xb2, 0x52, 0xbd, 0x4a, 0x8c, 0x5f, 0x73, 0x63, 0xbc, 0x36, 0x6e, 0x83, 0xf2, 0xb3,
            0xa4, 0x97, 0xaf, 0x1a, 0xdc, 0x77, 0xe, 0xc5, 0x5e, 0xa2, 0xbc, 0xc3, 0xe0, 0xda,
            0x6b, 0x40, 0x22, 0x4, 0x40, 0xb8, 0x79, 0xc0, 0x31, 0x16, 0x6b, 0xc9, 0x8e, 0x2b,
            0x67, 0x85, 0xb4, 0x41, 0x4d, 0x12, 0x93, 0xb9, 0x0, 0x5d, 0xcf, 0x20, 0xeb, 0xcd,
            0x4f, 0x30, 0x11, 0xfc, 0x17, 0x73, 0x7e, 0x95, 0x4e, 0xcb, 0x96, 0x11, 0xac, 0xe8,
            0x92, 0x80, 0x98, 0x39, 0x48, 0x34, 0x93, 0xd8, 0x59, 0x6b, 0xdf, 0x11, 0x3d, 0xad,
            0xb, 0x6, 0x68, 0x7, 0x6a, 0x65, 0xd3, 0x16, 0x7e, 0x64, 0xc, 0x6b, 0xc9, 0x1d, 0xa0,
            0x4a, 0x9d, 0xa6, 0x21, 0x4b, 0xec, 0x19, 0x40, 0x7f, 0x39, 0x4a, 0xd9, 0x36, 0x47,
            0xca, 0x43, 0x4a, 0xce, 0x30, 0x68, 0x22, 0x87, 0x4f, 0xa9, 0xcc, 0x2a, 0x7b, 0x82,
            0xb4, 0xe1, 0x8b, 0x12, 0x68, 0x1, 0x45, 0xbf, 0x52, 0x37, 0x5a, 0x5, 0x8, 0x74, 0xf3,
            0xcc, 0x2c, 0x70, 0x3e, 0x34, 0xe1, 0xb1, 0x6a, 0x23, 0xbe, 0xa4, 0x3, 0x23, 0x73,
            0x58, 0x81, 0xc9, 0x96, 0x47, 0xff, 0x79, 0x23, 0x18, 0x7c, 0xcc, 0xcc, 0x49, 0xca,
            0xce, 0xbb, 0x6d, 0x40, 0x6, 0x88, 0x14, 0x9b, 0x2a, 0x66, 0xa7, 0x20, 0x3e, 0xf1,
            0x6a, 0x87, 0xb3, 0x53, 0x5c, 0x64, 0xc2, 0xa5, 0x40, 0x7f, 0x7f, 0x1, 0x44, 0x69,
            0x53, 0x64, 0x37, 0x1c, 0x6, 0x7c, 0x22, 0x3b, 0x8c, 0x45, 0x9, 0xf4, 0x6a, 0x5d, 0x85,
            0x60, 0xa9, 0x5e, 0xd3, 0x64, 0xb, 0xe9, 0x4e, 0x5d, 0x61, 0x69, 0x71, 0x88, 0x29,
            0x92, 0x10, 0x86, 0xfe, 0xe7, 0x7a, 0xaf, 0x30, 0x66, 0x79, 0xf0, 0x7f, 0xc5, 0xf1,
            0x11, 0x5, 0x8b, 0x28, 0xb4, 0xf9, 0x99, 0xd, 0x5a, 0x51, 0x71, 0x2b, 0x81, 0x5c, 0x95,
            0x7e, 0x36, 0xf7, 0x93, 0xe, 0x7, 0x9a, 0x31, 0x69, 0x37, 0xfe, 0xc3, 0x2b, 0x37, 0xa3,
            0x14, 0x37, 0xb0, 0x77, 0x69, 0x8a, 0x51, 0x93, 0xd2, 0x2e, 0xc3, 0x27, 0x95, 0x22,
            0xe8, 0x89, 0xd7, 0x64, 0x57, 0xc7, 0xe7, 0x9a, 0x9, 0x5, 0x2e, 0xc4, 0xe6, 0x72, 0x19,
            0xe3, 0x9c, 0x8, 0xe0, 0x28, 0xa2, 0xfa, 0x84, 0xf, 0x65, 0x39, 0x2e, 0xb7, 0xcc, 0x9b,
            0xa6, 0xa6, 0xfc, 0x1c, 0x38, 0xf0, 0xf6, 0x3d, 0x94, 0xc8, 0x4b, 0xe, 0x4a, 0x5b,
            0xa6, 0xd3, 0x8b, 0x32, 0x53, 0x96, 0xd, 0xf7, 0x2b, 0xfd, 0xf9, 0x64, 0x7e, 0x39,
            0x21, 0xe8, 0x24, 0x99, 0xe1, 0x90, 0x7f, 0x97, 0x57, 0xbd, 0x4a, 0x0, 0x6b, 0xf8,
            0x42, 0xbf, 0x45, 0x18, 0xaa, 0x98, 0x98, 0x62, 0x10, 0xb1, 0xbb, 0xeb, 0xd2, 0xb3,
            0xb6, 0x83, 0x7d, 0x49, 0xa2, 0x30, 0x93, 0x90, 0x70, 0xc, 0xc7, 0xaa, 0x15, 0xe2,
            0x36, 0xc5, 0x14, 0x6d, 0xdc, 0x49, 0x15, 0x56, 0x2c, 0x3e, 0xa, 0x5, 0x6c, 0xa7, 0xdb,
            0x14, 0x73, 0x87, 0x3b, 0x73, 0x62, 0x62, 0x58, 0xb4, 0x2f, 0x47, 0x43, 0x48, 0xf5,
            0x86, 0xf, 0xbe, 0xda, 0x14, 0x75, 0x60, 0x4c, 0xd7, 0xc, 0x0, 0xb3, 0x27, 0xc9, 0x4b,
            0x34, 0x33, 0x30, 0x70, 0x50, 0x1d, 0x7a, 0x1b, 0xe, 0x54, 0x79, 0x65, 0xa5, 0x2, 0x24,
            0xe2, 0x7c, 0x32, 0x19, 0x6f, 0xa2, 0x91, 0xb3, 0x3a, 0xd2, 0x7c, 0xa9, 0xf3, 0x98,
            0xab, 0x87, 0x1a, 0x80, 0xb1, 0x47, 0x1f, 0xa3, 0xa1, 0xd5, 0xa3, 0x4b, 0xfb, 0xd5,
            0x4d, 0x85, 0x5c, 0xab, 0xa9, 0xbc, 0xb3, 0x2e, 0x97, 0x4a, 0xdb, 0x28, 0x4f, 0x3a,
            0x94, 0x7, 0xf5, 0x1c, 0x99, 0xf9, 0xbc, 0x70, 0x9e, 0x8c, 0x64, 0x87, 0xf1, 0xb1, 0xb,
            0xf2, 0x41, 0xbf, 0x16, 0x25, 0x83, 0xcc, 0x20, 0x98, 0x0, 0x52, 0xdf, 0x1a, 0xb2,
            0x48, 0x99, 0x49, 0x7a, 0x69, 0x4b, 0xa5, 0x11, 0x34, 0xbd, 0x5c, 0x77, 0xa8, 0x37,
            0xc5, 0x9d, 0x69, 0x7c, 0xd3, 0xdc, 0x58, 0x81, 0x2a, 0x48, 0x9a, 0x1a, 0xa5, 0x11,
            0x40, 0x53, 0x38, 0xf0, 0x4c, 0x25, 0xd7, 0xa4, 0x56, 0x27, 0x4c, 0xd4, 0xf0, 0x70,
            0x9a, 0x72, 0xb6, 0xc1, 0xd4, 0x8f, 0x55, 0xa7, 0x2d, 0x32, 0xbc, 0x92, 0xf5, 0x18,
            0xca, 0x13, 0xbb, 0xc8, 0xc6, 0x4a, 0xa9, 0x16, 0x4a, 0xc0, 0x4a, 0x2c, 0x72, 0x49,
            0xa4, 0x3a, 0xf5, 0xea, 0x8e, 0xc7, 0x9a, 0x89, 0xab, 0xb, 0xca, 0x57, 0x8a, 0xad,
            0xab, 0xfc, 0xa6, 0x3b, 0x34, 0xf, 0xfa, 0xf5, 0xac, 0xd2, 0x60, 0x82, 0x5b, 0xf4,
            0x94, 0xf7, 0xd2, 0xac, 0x7f, 0xb8, 0x8d, 0xf8, 0x9b, 0x63, 0xec, 0x50, 0x83, 0x35,
            0x5, 0xa7, 0xa, 0x82, 0x47, 0xf1, 0x34, 0x88, 0x64, 0xd2, 0x30, 0x1e, 0x88, 0x2, 0x78,
            0xe3, 0x63, 0x86, 0x75, 0x22, 0x5b, 0xe1, 0xbd, 0xc6, 0x18, 0x13, 0x46, 0x8c, 0x2,
            0x43, 0xac, 0x64, 0xfc, 0x21, 0x65, 0x14, 0x80, 0x11, 0x3, 0xb2, 0x15, 0x6d, 0x1, 0x64,
            0x3e, 0x63, 0x54, 0x81, 0x67, 0x62, 0xd9, 0xe9, 0xa2, 0x94, 0xc2, 0x41, 0xcf, 0x91,
            0x59, 0x2f, 0x76, 0x4b, 0xcb, 0xaa, 0xa, 0x46, 0x16, 0x3f, 0xab, 0x76, 0x35, 0x7a,
            0x93, 0xcb, 0xfc, 0x20, 0xb1, 0xd0, 0x1a, 0x97, 0x64, 0x69, 0x9a, 0x52, 0x65, 0x6e,
            0xa5, 0x9a, 0x64, 0xa0, 0x9f, 0xe2, 0xcd, 0xea, 0x51, 0xb7, 0xbb, 0x78, 0xd8, 0x5c,
            0x51, 0x3b, 0x25, 0x4e, 0x44, 0x67, 0xcc, 0x47, 0xd, 0xfa, 0x5, 0x73, 0x54, 0x90, 0x6c,
            0x51, 0x94, 0xad, 0xf8, 0xe8, 0xde, 0x2c, 0xe5, 0x18, 0x2f, 0x77, 0xbd, 0x27, 0xe8,
            0xf5, 0x7b, 0x1f, 0xe, 0x64, 0x98, 0x92, 0xc, 0xaa, 0x88, 0xb3, 0xfc, 0x39, 0x32, 0x1d,
            0x60, 0x92, 0xe5, 0x8b, 0x20, 0xab, 0x4b, 0x2a, 0x22, 0x0, 0x1d, 0x0, 0x20, 0xd, 0x2c,
            0x36, 0xb, 0x3a, 0x5d, 0xe8, 0x5a, 0x53, 0xb3, 0xf1, 0xa3, 0xed, 0xe4, 0xe9, 0xd2,
            0x60, 0x46, 0xc4, 0xe4, 0x7a, 0x5e, 0x32, 0xea, 0xd6, 0x78, 0x88, 0x2c, 0x1b, 0xdd,
            0xd8, 0x49,
        ];
        let client_hello = ClientHello {
            tls_version: 0x0304,
            sni: Some("incoming.telemetry.mozilla.org"),
            cipher_suites: [
                0x1302, 0x1303, 0x1301, 0xc02c, 0xc030, 0x009f, 0xcca9, 0xcca8, 0xccaa, 0xc02b,
                0xc02f, 0x009e, 0xc024, 0xc028, 0x006b, 0xc023, 0xc027, 0x0067, 0xc00a, 0xc014,
                0x0039, 0xc009, 0xc013, 0x0033, 0x009d, 0x009c, 0x003d, 0x003c, 0x0035, 0x002f,
            ]
            .into_iter()
            .collect(),
            extensions: [0xff01, 0, 11, 10, 16, 22, 23, 49, 13, 43, 45, 51]
                .into_iter()
                .collect(),
            signature_algorithms: [
                0x0905, 0x0906, 0x0904, 0x0403, 0x0503, 0x0603, 0x0807, 0x0808, 0x081a, 0x081b,
                0x081c, 0x0809, 0x080a, 0x080b, 0x0804, 0x0805, 0x0806, 0x0401, 0x0501, 0x0601,
                0x0303, 0x0301, 0x0302, 0x0402, 0x0502, 0x0602,
            ]
            .into_iter()
            .collect(),
            alpn: [b"h2".as_slice(), b"http/1.1".as_slice()]
                .into_iter()
                .collect(),
            //ja4: "t13d3012h2_1d37bd780c83_882d495ac381".try_into().unwrap(),
        };

        assert_eq!(
            ClientHello::try_from(HEADER).expect("example data contains correct client hello"),
            client_hello
        );
    }

    fn parse_hexdump(dump: &str) -> Vec<u8, 4096> {
        let mut bytes = Vec::new();

        for line in dump.lines().filter(|l| !l.trim().is_empty()) {
            let hex_str = line
                .split_at(usize::min(54, line.len()))
                .0
                .splitn(2, ' ')
                .last()
                .unwrap()
                .trim();
            bytes.extend(hex_str.split(' ').filter(|s| !s.is_empty()).map(|s| {
                u8::from_str_radix(s, 16)
                    .map_err(|_err| panic!("{}", s))
                    .unwrap()
            }));
        }

        bytes
    }

    #[test]
    fn test_ip_firefox_ech() {
        let header = parse_hexdump(include_str!("./testcases/ip-firefox-ech.hex"));

        let output = ClientHello::try_from(header.as_slice())
            .expect("example data contains correct client hello");

        assert_eq!(output.tls_version(), 0x0304);
        assert_eq!(output.sni(), None);
        assert_eq!(output.alpn(), &[&b"h2"[..], &b"http/1.1"[..]]);
        assert_eq!(
            Ja4Fingerprint::calculate(&output).as_ref(),
            "t13i1716h2_5b57614c22b0_3cbfd9057e0d"
        );
    }

    #[test]
    fn test_hostname_firefox() {
        let header = parse_hexdump(include_str!("./testcases/hostname-firefox.hex"));

        let output = ClientHello::try_from(header.as_slice())
            .expect("example data contains correct client hello");

        assert_eq!(output.tls_version(), 0x0304);
        assert_eq!(output.sni(), Some("rappet.xyz"));
        assert_eq!(output.alpn(), &[&b"h2"[..], &b"http/1.1"[..]]);
        assert_eq!(
            Ja4Fingerprint::calculate(&output).as_ref(),
            "t13d1717h2_5b57614c22b0_3cbfd9057e0d"
        );
    }

    #[test]
    fn test_hostname_chrome() {
        let header = parse_hexdump(include_str!("./testcases/hostname-chrome.hex"));

        let output = ClientHello::try_from(header.as_slice())
            .expect("example data contains correct client hello");

        assert_eq!(output.tls_version(), 0x0304);
        assert_eq!(output.sni(), Some("rappet.xyz"));
        assert_eq!(output.alpn(), &[&b"h2"[..], &b"http/1.1"[..]]);
        assert_eq!(
            Ja4Fingerprint::calculate(&output).as_ref(),
            "t13d1516h2_8daaf6152771_02713d6af862"
        );
    }

    #[test]
    fn test_hostname_chromium() {
        let header = parse_hexdump(include_str!("./testcases/hostname-chromium.hex"));

        let output = ClientHello::try_from(header.as_slice())
            .expect("example data contains correct client hello");

        assert_eq!(output.tls_version(), 0x0304);
        assert_eq!(output.sni(), Some("rappet.xyz"));
        assert_eq!(output.alpn(), &[&b"h2"[..], &b"http/1.1"[..]]);
        assert_eq!(
            Ja4Fingerprint::calculate(&output).as_ref(),
            "t13d1516h2_8daaf6152771_d8a2da3f94cd"
        );
    }

    #[test]
    fn test_hostname_curl() {
        let header = parse_hexdump(include_str!("./testcases/hostname-curl.hex"));

        let output = ClientHello::try_from(header.as_slice())
            .expect("example data contains correct client hello");

        assert_eq!(output.tls_version(), 0x0304);
        assert_eq!(output.sni(), Some("rappet.xyz"));
        assert_eq!(output.alpn(), &[&b"h2"[..], &b"http/1.1"[..]]);
        assert_eq!(
            Ja4Fingerprint::calculate(&output).as_ref(),
            "t13d3012h2_1d37bd780c83_882d495ac381"
        );
    }

    #[test]
    fn test_u16_slice_to_hex() {
        let input = &[0x1234, 0x5678, 0x9abc];
        let output = u16_slice_to_hex(input).expect("does not exceed length");
        assert_eq!(output.as_slice(), b"1234,5678,9abc");
    }

    #[test]
    fn test_empty_tls_version() {
        // source: Fuzzer
        let input = [
            22, 0, 1, 0, 96, 1, 0, 0, 72, 72, 72, 72, 72, 72, 72, 72, 72, 0, 0, 0, 0, 0, 100, 0, 0,
            0, 0, 0, 5, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 16, 0, 0,
            0, 0, 0, 0, 0, 43, 0, 1, 0, 96, 1, 0, 72, 72, 72, 72, 72, 72, 72, 72, 0, 0, 0, 0, 0, 0,
            0, 4, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 85, 0, 0, 0, 0, 0, 0, 72, 0,
        ];
        let _ = ClientHello::try_from(&input[..]).unwrap();
    }

    #[test]
    fn test_many_compression_args() {
        // source: Fuzzer
        let input = [
            22, 120, 0, 0, 105, 1, 0, 0, 101, 101, 101, 101, 101, 101, 1, 0, 0, 0, 0, 0, 0, 11, 37,
            101, 0, 0, 112, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 101, 101, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0,
            0, 0, 0, 0, 0, 50, 8, 8, 8, 8, 8, 8, 8, 8, 37, 12, 0, 0, 0, 0, 0, 0, 0, 0, 8, 101, 101,
            101, 101, 160, 154, 8, 8, 8, 8, 8, 0, 0, 0, 0, 112, 1, 101, 101, 101, 0, 0, 41, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let _ = ClientHello::try_from(&input[..]).unwrap();
    }

    #[test]
    fn test_fuzz_1() {
        // source: Fuzzer
        let input = [
            22, 120, 0, 0, 105, 1, 0, 0, 101, 101, 101, 101, 101, 101, 1, 0, 0, 0, 0, 0, 0, 11, 37,
            101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 101, 165, 101, 101, 117, 101, 0, 0, 0, 0, 0, 0, 62, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
        ];
        let _ = ClientHello::try_from(&input[..]).unwrap();
    }

    #[test]
    fn test_fuzz_2() {
        // source: Fuzzer
        let input = [
            22, 120, 0, 0, 111, 1, 0, 0, 101, 101, 101, 1, 109, 101, 159, 255, 0, 255, 255, 120,
            11, 14, 101, 116, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0, 0, 0, 0,
            0, 48, 0, 0, 0, 0, 0, 16, 0, 10, 0, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 10, 0, 5, 0,
            0, 0, 0, 5, 0, 0, 0, 0, 16, 0, 10, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 1, 150, 0, 0, 158,
            158, 158, 158, 158, 91, 158, 158, 158, 238, 238, 238, 238, 158, 158, 158, 0,
        ];
        let _ = ClientHello::try_from(&input[..]).unwrap();
    }

    #[test]
    fn test_fuzz_3() {
        // source: fuzzer
        let input = [
            22, 120, 0, 0, 112, 1, 0, 0, 101, 101, 101, 1, 109, 101, 101, 0, 0, 0, 0, 0, 0, 75,
            101, 101, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 44,
            0, 0, 0, 4, 0, 0, 0, 50, 0, 0, 0, 0, 0, 16, 0, 10, 0, 5, 3, 150, 0, 0, 158, 0, 0, 157,
            0, 16, 0, 10, 0, 5, 0, 0, 0, 0, 8, 8, 43, 3, 150, 0, 158, 158, 158, 159, 158, 91, 158,
            158, 158, 158, 158, 0, 0, 0, 0, 0, 211, 143, 211, 211, 211, 211, 211, 211, 0, 0,
        ];
        let _ = ClientHello::try_from(&input[..]).unwrap();
    }
}
